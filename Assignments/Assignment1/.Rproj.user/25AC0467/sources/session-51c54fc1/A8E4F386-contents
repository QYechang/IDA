---
title: "Assignment 1"
author: "Nicholas Jacob"
date: "2024-08-19"
output: pdf_document
---

```{r setup}
knitr::opts_chunk$set(echo = TRUE)
```

## Using R:  Vectors


Using `c` to combine the values, we see that $x$ is a vector.
```{r 1a}
x<- c(3,12,6,-5,0,8,15,1,-10,7)
is.vector(x)
```
To create the new vector $y$ as a sequence from the min of $x$ to the max of $x$, we do the following:
```{r 1b}
y <-seq(min(x),max(x), length.out = 10)
y
```
I was not familiar with the `length.out` command but found it in the Help package to see that it would restrict the output to that many elements.

We compute the desired stats next

```{r 1c}
#consider changing this one with some tidy code
sum(x)
sum(y)
mean(x)
mean(y)
sd(x)
sd(y)
var(x)
var(y)
mad(x)
mad(y)
quantile(x,1/4)
quantile(y,1/4)
quantile(x,3/4)
quantile(y,3/4)
quantile(x,1/5)
quantile(y,1/5)
quantile(x,3/5)
quantile(y,3/5)
quantile(x,2/5)
quantile(y,2/5)
quantile(x,4/5)
quantile(y,4/5)
```
To do sampling with replacement we do the following

```{r 1d}
sample(x,7,TRUE)
```
The `TRUE` gives the replacement.  Some instances do see repeated vales.

Next we do the `t.test`
```{r}
t.test(x,y)
```
We fail to reject the null hypothesis here.  There is no evidence to suggest that the mean values are different.

Next we explore the `order` function.

```{r 1g}
order(x)
```
We see this gives the order of the elements of $x$, indexing at 1 as the lowest value.  To sort $x$ we could do the following.
```{r 1g2}
sort(x)
```

We could also use the order function as follows:
```{r}
x[order(x)]
```

Inside the [] we are giving the index of the value we want.  So this will return the values in the proper order.  Lastly we will preform the paired t.test.

```{r}
t.test(sort(x),y,paired = TRUE)
```

The result here is still not significant (for p =0.05) but is much closer than in the non-paired data.  I am actually quite surprised at that result but since $y$ is build off of $x$ and now they are both sequential I could see why they might be statistically equivalent on average.

A logical test for negativity is simply
```{r}
x>0
```

Since this gives the Boolean, we can use that as the index for $x$ and overwrite $x$
```{r}
x <- x[x>0]
x
```

## Using R:  Some Missing Values

```{r}
col1 <- c(1,2,3,NA,5)
col2 <- c(4,5,6,89,101)
col3 <- c(45,NA,66,121,201)
col4 <- c(14,NA,13,NA,27)
X <- rbind (col1,col2,col3,col4)

X


```

So we see $X$ has NA in three rows.  We can find the NAs with the following
```{r}
is.na(X)
```
To get to which rows have the NAs, we sum across the booleans and ask that the sum in that row is larger than 0.  Then we use the rownames command to give out those rows names that do have some NAs.
```{r}
rownames(X)[rowSums(is.na(X))>0]
```

For the next piece, we define $y$

```{r}
y <- c(3,12,99,99,7,99,21)
y
```

We will find the 99s with this peice of code
```{r}
y == 99
```

We set that to the NA value with this which overwrites y values.
```{r}
y[y==99] = NA

y
```

I count the NA values with a sum of the booleans

```{r}
sum(is.na(y))
```

##Using R:  IDE

Here I have read the data in.  I utilize the head command to display the first 6 rows.
```{r}
college = read.csv('college.csv')
head(college)
```

Next, I change the rownames to the university name and delete that column.
```{r}
rownames (college) <- college [,1]
college <- college [,-1]
head(college)
```

Next we examine some stats on the data
```{r}
summary(college)
```

I am not familiar with the `pairs` command but here goes
```{r}
pairs(college[,2:10])
```
